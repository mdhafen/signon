<?php
// ldapsearch -H ldap://ldap.mydomain.com -x -s base -b "cn=subschema" objectclasses
// Schemas are large and mostly static.  It is recommended they be cached.
require_once( $config['base_dir'] ."/lib/data.phpm" );

function get_schema_objects( $ldap ) {
	$subschema = get_subschema_base( $ldap );

	$set = ldap_read( $ldap['handle'], $subschema, 'objectClass=*', array('objectclasses') );
	$schema = ldap_get_entries( $ldap['handle'], $set );

	$objects = array();
	foreach ( $schema as $entry ) {
	for ( $i = 0; $i < $entry['objectclasses']['count']; $i++ ) {
		$oC_str = $entry['objectclasses'][$i];
		$o = parse_asn_schema( $oC_str );
		if ( ! empty( $o ) && ! empty($o['NAME']) && ! empty($o['NAME'][0]) ) {
			$objects[ $o['NAME'][0] ] = $o;
		}
	}
	}

	return $objects;
}

function get_schema_attributes( $ldap ) {
	$subschema = get_subschema_base( $ldap );

	$set = ldap_read( $ldap['handle'], $subschema, 'objectClass=*', array('attributeTypes') );
	$schema = ldap_get_entries( $ldap['handle'], $set );

	$attrs = array();
	foreach ( $schema as $entry ) {
	for ( $i = 0; $i < $entry['attributetypes']['count']; $i++ ) {
		$attr_str = $entry['attributetypes'][$i];
		$a = parse_asn_schema( $attr_str );
		if ( ! empty( $a ) && ! empty($a['NAME']) ) {
			foreach ( $a['NAME'] as $name ) {
				$attrs[ $name ] = $a;
			}
		}
	}
	}

	return $attrs;
}

function get_subschema_base( $ldap ) {
	$set = ldap_read( $ldap['handle'], '', 'objectClass=*', array('*','subschemaSubentry') );
	$schema = ldap_get_entries( $ldap['handle'], $set );
	$subschema = $schema[0]['subschemasubentry'][0];

	return $subschema;
}

/*
   objectClass info: http://www.zytrax.com/books/ldap/ch3/
ObjectClassDescription = "(" whsp
 numericoid whsp      ; ObjectClass identifier
 [ "NAME" qdescrs ]
 [ "DESC" qdstring ]
 [ "OBSOLETE" whsp ]
 [ "SUP" oids ]       ; Superior ObjectClasses
 [ ( "ABSTRACT" / "STRUCTURAL" / "AUXILIARY" ) whsp ]
                      ; default structural
 [ "MUST" oids ]      ; AttributeTypes
 [ "MAY" oids ]       ; AttributeTypes
  whsp ")"

   example:
 ( 1.3.6.1.4.1.7165.2.2.16 NAME 'sambaTrustedDomain' DESC 'Samba
  Trusted Domain Object' SUP top STRUCTURAL MUST cn MAY ( sambaTrustType $ sam
 baTrustAttributes $ sambaTrustDirection $ sambaTrustPartner $ sambaFlatName $
  sambaTrustAuthOutgoing $ sambaTrustAuthIncoming $ sambaSecurityIdentifier $ 
 sambaTrustForestTrustInfo $ sambaTrustPosixOffset $ sambaSupportedEncryptionT
 ypes ) )

AttributeTypeDescription = "(" whsp
   numericoid whsp     ; AttributeType identifier
 [ "NAME" qdescrs ]             ; name used in AttributeType
 [ "DESC" qdstring ]            ; description
 [ "OBSOLETE" whsp ]
 [ "SUP" woid ]                 ; derived from this other
                                ; AttributeType
 [ "EQUALITY" woid              ; Matching Rule name
 [ "ORDERING" woid              ; Matching Rule name
 [ "SUBSTR" woid ]              ; Matching Rule name
 [ "SYNTAX" whsp noidlen whsp ] ; Syntax OID
 [ "SINGLE-VALUE" whsp ]        ; default multi-valued
 [ "COLLECTIVE" whsp ]          ; default not collective
 [ "NO-USER-MODIFICATION" whsp ]; default user modifiable
 [ X-ORDERED whsp type ]        ; non-standard - default not X-ORDERED
 [ "USAGE" whsp AttributeUsage ]; default userApplications
 whsp ")"

 */
function parse_asn_schema( $asn_str ) {
	$schema_flags = array(
		'STRUCTURAL', 'AUXILIARY', 'ABSTRACT',
		'OBSOLETE', 'SINGLE-VALUE', 'COLLECTIVE',
		'NO-USER-MODIFICATION',
	);
	$object = array();
	$asn_str = substr( $asn_str, 2, -2 );

	$end_pos = strpos( $asn_str, " " );
	$object['OID'] = substr( $asn_str, 0, $end_pos );
	$asn_str = substr( $asn_str, $end_pos + 1 );

	while ( ! empty( $asn_str ) ) {
		$end_pos = strpos( $asn_str, " " );
		$key = substr( $asn_str, 0, $end_pos );
		$asn_str = substr( $asn_str, $end_pos + 1 );
		$values = array();

		if ( in_array( $key, $schema_flags ) ) {
			$object[$key] = 1;
			continue;
		}

		$char = substr( $asn_str, 0, 1 );
		switch ($char) {
			case "(":
				$end_pos = strpos( $asn_str, ")" );
				$set = substr( $asn_str, 1, $end_pos - 1 );
				$values = preg_split( "/[\s$]+/", $set, 0, PREG_SPLIT_NO_EMPTY );
				$end_pos++;
				break;
			case "'":
				$end_pos = strpos( $asn_str, "'", 1 );
				$values[] = substr( $asn_str, 1, $end_pos - 1 );
				$end_pos++;
				break;
			default:
				$end_pos = @strpos( $asn_str, " ", 1 );
				if ( $end_pos === false ) {
					$end_pos = strlen( $asn_str );
				}
				$values[] = substr( $asn_str, 0, $end_pos );
				break;
		}
		$asn_str = substr( $asn_str, $end_pos + 1 );

		reset( $values );
		while ( list($k,$v) = each($values) ) {
			$values[$k] = trim( $values[$k], " '" );
		}

		if ( ! empty($key) && ! empty($values) ) {
			$object[$key] = $values;
		}
	}

	return $object;
}

function schema_get_object_requirements( $ldap, $objectClasses ) {
	if ( empty( $_SESSION['schema_objects'] ) ) {
		$schema_objects = get_schema_objects($ldap);
		$_SESSION['schema_objects'] = $schema_objects;
	}
	else {
		$schema_objects = $_SESSION['schema_objects'];
	}

	$must = array();
	$may = array();
	for ( $i = 0; $i < count($objectClasses); $i++ ) {
		$oc = $objectClasses[$i];

		if ( ! empty($schema_objects[$oc]['SUP']) ) {
			foreach ( $schema_objects[$oc]['SUP'] as $sup_oc ) {
				$objectClasses[] = $sup_oc;
			}
		}

		if ( ! empty($schema_objects[$oc]['MUST']) ) {
			$must = array_merge( $must, $schema_objects[$oc]['MUST'] );
		}
		if ( ! empty($schema_objects[$oc]['MAY']) ) {
			$may = array_merge( $may, $schema_objects[$oc]['MAY'] );
		}
	}

	$must = array_unique( $must );
	$may = array_unique( $may );
	$may = array_diff( $may, $must );

	sort( $must );
	sort( $may );

	return array( $must, $may );
}

?>
